import { Icon, List, showToast, Toast, ActionPanel } from "@raycast/api";
import { useCachedState } from "@raycast/utils";
import { ModelListItem } from "./types";
import { useModels } from "./utils/use-models";
import { getOrganizationLogo } from "./utils/organization-logos";
import {
  ShowDetailsAction,
  ModelDetailsLinkAction,
  OpenPlaygroundAction,
  CompareWithSubmenu,
} from "./components/actions/ModelActions";
import { formatParamCount, formatContextSize, formatPriceFromString } from "./utils/formatting";

type SortCriteria = "input-price" | "output-price" | "context-window" | "throughput" | "params";

export default function Command() {
  const [sortBy, setSortBy] = useCachedState<SortCriteria>("models-sort-by", "params");
  const { data: models, isLoading, error } = useModels(true, true);

  if (error) {
    showToast({
      style: Toast.Style.Failure,
      title: "Failed to load models",
      message: error instanceof Error ? error.message : "Unknown error",
    });
  }

  // Sort models based on selected criteria
  const sortedModels = models
    ? [...models].sort((a, b) => {
        switch (sortBy) {
          case "input-price":
            return comparePrices(a.price_per_input_token, b.price_per_input_token);
          case "output-price":
            return comparePrices(a.price_per_output_token, b.price_per_output_token);
          case "context-window":
            return compareNumbers(a.context, b.context, true); // descending
          case "throughput":
            return compareThroughput(a.throughput, b.throughput);
          case "params":
            return compareNumbers(a.params, b.params, true); // descending
          default:
            return 0;
        }
      })
    : [];

  return (
    <List
      isLoading={isLoading}
      searchBarPlaceholder="Search models..."
      searchBarAccessory={
        <List.Dropdown tooltip="Sort by" value={sortBy} onChange={(value) => setSortBy(value as SortCriteria)}>
          <List.Dropdown.Section title="Performance">
            <List.Dropdown.Item title="Parameters" value="params" icon={Icon.Calculator} />
            <List.Dropdown.Item title="Context Window" value="context-window" icon={Icon.Box} />
            <List.Dropdown.Item title="Throughput" value="throughput" icon={Icon.Bolt} />
          </List.Dropdown.Section>

          <List.Dropdown.Section title="Pricing">
            <List.Dropdown.Item title="Input Price" value="input-price" icon={Icon.Coins} />
            <List.Dropdown.Item title="Output Price" value="output-price" icon={Icon.Coins} />
          </List.Dropdown.Section>
        </List.Dropdown>
      }
    >
      {sortedModels.length === 0 && !isLoading ? (
        <List.EmptyView icon={Icon.MagnifyingGlass} title="No models found" description="Try adjusting your search" />
      ) : (
        sortedModels.map((model: ModelListItem) => {
          const accessories: List.Item.Accessory[] = [];

          // Display only the accessory for the selected sort criteria
          switch (sortBy) {
            case "input-price":
              if (model.price_per_input_token) {
                accessories.push({
                  text: formatPriceFromString(model.price_per_input_token),
                  tooltip:
                    "Price per token included in the request/message sent to the API, represented as USD per million Tokens.",
                });
              }
              break;
            case "output-price":
              if (model.price_per_output_token) {
                accessories.push({
                  text: formatPriceFromString(model.price_per_output_token),
                  tooltip:
                    "Price per token generated by the model (received from the API), represented as USD per million Tokens",
                });
              }
              break;
            case "context-window":
              if (model.context !== null) {
                accessories.push({
                  text: formatContextSize(model.context),
                  tooltip:
                    "Maximum number of combined input & output tokens. Output tokens commonly have a significantly lower limit",
                });
              }
              break;
            case "throughput":
              if (model.throughput) {
                accessories.push({
                  text: `${model.throughput} ts/sec`,
                  tooltip: "Tokens per second",
                });
              }
              break;
            case "params":
              if (model.params !== null) {
                accessories.push({
                  text: formatParamCount(model.params),
                  tooltip: "Parameters",
                });
              }
              break;
          }

          return (
            <List.Item
              key={model.model_id}
              icon={getOrganizationLogo(model.organization_id)}
              title={model.name}
              subtitle={model.organization}
              keywords={[model.organization_id, model.organization, model.model_id].filter(Boolean) as string[]}
              accessories={accessories}
              actions={
                <ActionPanel>
                  <ShowDetailsAction modelId={model.model_id} />
                  <ModelDetailsLinkAction modelId={model.model_id} />
                  <OpenPlaygroundAction modelId={model.model_id} />
                  <CompareWithSubmenu modelId={model.model_id} />
                </ActionPanel>
              }
            />
          );
        })
      )}
    </List>
  );
}

/**
 * Compares two price strings (e.g., "$0.50/1M tokens")
 * Returns negative if a < b, positive if a > b, 0 if equal
 * Sorts in descending order (higher prices first)
 */
function comparePrices(a: string | null, b: string | null): number {
  if (!a && !b) return 0;
  if (!a) return 1;
  if (!b) return -1;

  const priceA = parsePrice(a);
  const priceB = parsePrice(b);

  if (priceA === null && priceB === null) return 0;
  if (priceA === null) return 1;
  if (priceB === null) return -1;

  return priceB - priceA; // descending - higher prices first
}

/**
 * Parses a price string like "$0.50/1M tokens" to a number
 */
function parsePrice(priceStr: string): number | null {
  const match = priceStr.match(/\$?([\d.]+)/);
  if (!match) return null;
  return parseFloat(match[1]);
}

/**
 * Compares two numbers
 * @param descending - If true, larger numbers come first
 */
function compareNumbers(a: number | null, b: number | null, descending: boolean = false): number {
  if (a === null && b === null) return 0;
  if (a === null) return 1;
  if (b === null) return -1;

  return descending ? b - a : a - b;
}

/**
 * Compares two throughput strings (e.g., "100 tokens/second")
 */
function compareThroughput(a: string | null, b: string | null): number {
  if (!a && !b) return 0;
  if (!a) return 1;
  if (!b) return -1;

  const throughputA = parseThroughput(a);
  const throughputB = parseThroughput(b);

  if (throughputA === null && throughputB === null) return 0;
  if (throughputA === null) return 1;
  if (throughputB === null) return -1;

  return throughputB - throughputA; // descending - higher throughput first
}

/**
 * Parses a throughput string like "100 tokens/second" to a number
 */
function parseThroughput(throughputStr: string): number | null {
  const match = throughputStr.match(/([\d.]+)/);
  if (!match) return null;
  return parseFloat(match[1]);
}
